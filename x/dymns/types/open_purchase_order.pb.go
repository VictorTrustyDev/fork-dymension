// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dymensionxyz/dymension/dymns/open_purchase_order.proto

package types

import (
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// OpenPurchaseOrder defines a purchase order for a Dym-Name.
// After expiry date, if no one has placed a bid, this OPO will be closed, no change.
// If there is a bid, the highest bid will win.
// OPO will be moved to historical records after completed, no matter reason.
type OpenPurchaseOrder struct {
	// The name of the Dym-Name being opened to purchase.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The last effective date of this OPO, after which the Dym-Name purchase is no longer valid.
	ExpireAt int64 `protobuf:"varint,2,opt,name=expire_at,json=expireAt,proto3" json:"expire_at,omitempty"`
	// The minimum price that the seller is willing to accept for the Dym-Name.
	MinPrice types.Coin `protobuf:"bytes,4,opt,name=min_price,json=minPrice,proto3" json:"min_price"`
	// The price that the seller is willing to sell the Dym-Name for, the OPO will be closed when the price is met.
	// If the sell price is zero, the OPO will be closed when the expire_at is reached and the highest bid win.
	SellPrice *types.Coin `protobuf:"bytes,5,opt,name=sell_price,json=sellPrice,proto3" json:"sell_price,omitempty"`
	// The highest bid on the OPO, if any. Price must be greater than or equal to the min_price.
	HighestBid *OpenPurchaseOrderBid `protobuf:"bytes,6,opt,name=highest_bid,json=highestBid,proto3" json:"highest_bid,omitempty"`
}

func (m *OpenPurchaseOrder) Reset()         { *m = OpenPurchaseOrder{} }
func (m *OpenPurchaseOrder) String() string { return proto.CompactTextString(m) }
func (*OpenPurchaseOrder) ProtoMessage()    {}
func (*OpenPurchaseOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c0ef1018f9a6fe, []int{0}
}
func (m *OpenPurchaseOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenPurchaseOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenPurchaseOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenPurchaseOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenPurchaseOrder.Merge(m, src)
}
func (m *OpenPurchaseOrder) XXX_Size() int {
	return m.Size()
}
func (m *OpenPurchaseOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenPurchaseOrder.DiscardUnknown(m)
}

var xxx_messageInfo_OpenPurchaseOrder proto.InternalMessageInfo

func (m *OpenPurchaseOrder) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OpenPurchaseOrder) GetExpireAt() int64 {
	if m != nil {
		return m.ExpireAt
	}
	return 0
}

func (m *OpenPurchaseOrder) GetMinPrice() types.Coin {
	if m != nil {
		return m.MinPrice
	}
	return types.Coin{}
}

func (m *OpenPurchaseOrder) GetSellPrice() *types.Coin {
	if m != nil {
		return m.SellPrice
	}
	return nil
}

func (m *OpenPurchaseOrder) GetHighestBid() *OpenPurchaseOrderBid {
	if m != nil {
		return m.HighestBid
	}
	return nil
}

// ActiveOpenPurchaseOrdersExpiration contains list of active OPOs, store expiration date mapped by Dym-Name.
// Used by hook to find out expired OPO instead of iterating through all records.
type ActiveOpenPurchaseOrdersExpiration struct {
	ExpiryByName map[string]int64 `protobuf:"bytes,1,rep,name=expiry_by_name,json=expiryByName,proto3" json:"expiry_by_name,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ActiveOpenPurchaseOrdersExpiration) Reset()         { *m = ActiveOpenPurchaseOrdersExpiration{} }
func (m *ActiveOpenPurchaseOrdersExpiration) String() string { return proto.CompactTextString(m) }
func (*ActiveOpenPurchaseOrdersExpiration) ProtoMessage()    {}
func (*ActiveOpenPurchaseOrdersExpiration) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c0ef1018f9a6fe, []int{1}
}
func (m *ActiveOpenPurchaseOrdersExpiration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveOpenPurchaseOrdersExpiration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActiveOpenPurchaseOrdersExpiration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActiveOpenPurchaseOrdersExpiration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveOpenPurchaseOrdersExpiration.Merge(m, src)
}
func (m *ActiveOpenPurchaseOrdersExpiration) XXX_Size() int {
	return m.Size()
}
func (m *ActiveOpenPurchaseOrdersExpiration) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveOpenPurchaseOrdersExpiration.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveOpenPurchaseOrdersExpiration proto.InternalMessageInfo

func (m *ActiveOpenPurchaseOrdersExpiration) GetExpiryByName() map[string]int64 {
	if m != nil {
		return m.ExpiryByName
	}
	return nil
}

type OpenPurchaseOrderBid struct {
	// The address of the account which placed the bid.
	Bidder string `protobuf:"bytes,1,opt,name=bidder,proto3" json:"bidder,omitempty"`
	// The price set by the bidder.
	Price types.Coin `protobuf:"bytes,2,opt,name=price,proto3" json:"price"`
}

func (m *OpenPurchaseOrderBid) Reset()         { *m = OpenPurchaseOrderBid{} }
func (m *OpenPurchaseOrderBid) String() string { return proto.CompactTextString(m) }
func (*OpenPurchaseOrderBid) ProtoMessage()    {}
func (*OpenPurchaseOrderBid) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c0ef1018f9a6fe, []int{2}
}
func (m *OpenPurchaseOrderBid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenPurchaseOrderBid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenPurchaseOrderBid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenPurchaseOrderBid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenPurchaseOrderBid.Merge(m, src)
}
func (m *OpenPurchaseOrderBid) XXX_Size() int {
	return m.Size()
}
func (m *OpenPurchaseOrderBid) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenPurchaseOrderBid.DiscardUnknown(m)
}

var xxx_messageInfo_OpenPurchaseOrderBid proto.InternalMessageInfo

func (m *OpenPurchaseOrderBid) GetBidder() string {
	if m != nil {
		return m.Bidder
	}
	return ""
}

func (m *OpenPurchaseOrderBid) GetPrice() types.Coin {
	if m != nil {
		return m.Price
	}
	return types.Coin{}
}

type HistoricalOpenPurchaseOrders struct {
	// List of closed OPOs of the same Dym-Name.
	OpenPurchaseOrders []OpenPurchaseOrder `protobuf:"bytes,1,rep,name=open_purchase_orders,json=openPurchaseOrders,proto3" json:"open_purchase_orders"`
}

func (m *HistoricalOpenPurchaseOrders) Reset()         { *m = HistoricalOpenPurchaseOrders{} }
func (m *HistoricalOpenPurchaseOrders) String() string { return proto.CompactTextString(m) }
func (*HistoricalOpenPurchaseOrders) ProtoMessage()    {}
func (*HistoricalOpenPurchaseOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c0ef1018f9a6fe, []int{3}
}
func (m *HistoricalOpenPurchaseOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HistoricalOpenPurchaseOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HistoricalOpenPurchaseOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HistoricalOpenPurchaseOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistoricalOpenPurchaseOrders.Merge(m, src)
}
func (m *HistoricalOpenPurchaseOrders) XXX_Size() int {
	return m.Size()
}
func (m *HistoricalOpenPurchaseOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_HistoricalOpenPurchaseOrders.DiscardUnknown(m)
}

var xxx_messageInfo_HistoricalOpenPurchaseOrders proto.InternalMessageInfo

func (m *HistoricalOpenPurchaseOrders) GetOpenPurchaseOrders() []OpenPurchaseOrder {
	if m != nil {
		return m.OpenPurchaseOrders
	}
	return nil
}

func init() {
	proto.RegisterType((*OpenPurchaseOrder)(nil), "dymensionxyz.dymension.dymns.OpenPurchaseOrder")
	proto.RegisterType((*ActiveOpenPurchaseOrdersExpiration)(nil), "dymensionxyz.dymension.dymns.ActiveOpenPurchaseOrdersExpiration")
	proto.RegisterMapType((map[string]int64)(nil), "dymensionxyz.dymension.dymns.ActiveOpenPurchaseOrdersExpiration.ExpiryByNameEntry")
	proto.RegisterType((*OpenPurchaseOrderBid)(nil), "dymensionxyz.dymension.dymns.OpenPurchaseOrderBid")
	proto.RegisterType((*HistoricalOpenPurchaseOrders)(nil), "dymensionxyz.dymension.dymns.HistoricalOpenPurchaseOrders")
}

func init() {
	proto.RegisterFile("dymensionxyz/dymension/dymns/open_purchase_order.proto", fileDescriptor_15c0ef1018f9a6fe)
}

var fileDescriptor_15c0ef1018f9a6fe = []byte{
	// 480 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x4d, 0x6b, 0xdb, 0x40,
	0x10, 0xf5, 0xfa, 0x8b, 0x78, 0x5c, 0x4a, 0xb3, 0x98, 0xe2, 0xba, 0x41, 0x35, 0x3a, 0xf9, 0xb4,
	0x22, 0x0e, 0x2d, 0xa1, 0x14, 0x4a, 0x54, 0x02, 0x3d, 0x94, 0x26, 0xa8, 0xb7, 0x5e, 0x84, 0x3e,
	0x06, 0x79, 0xa9, 0xb5, 0x2b, 0xb4, 0x6b, 0x63, 0xf5, 0x0f, 0xf4, 0xda, 0xfe, 0xab, 0x1c, 0x73,
	0xec, 0xa9, 0x2d, 0xf6, 0x1f, 0x29, 0x92, 0x96, 0x10, 0x50, 0x1a, 0x37, 0xb7, 0x37, 0xab, 0xf7,
	0xe6, 0x31, 0xf3, 0x34, 0xf0, 0x2a, 0x2e, 0x52, 0x14, 0x8a, 0x4b, 0xb1, 0x29, 0xbe, 0x3a, 0x37,
	0x45, 0x89, 0x84, 0x72, 0x64, 0x86, 0xc2, 0xcf, 0x56, 0x79, 0xb4, 0x08, 0x14, 0xfa, 0x32, 0x8f,
	0x31, 0x67, 0x59, 0x2e, 0xb5, 0xa4, 0x47, 0xb7, 0x75, 0xec, 0xa6, 0x60, 0x95, 0x6e, 0x32, 0x4a,
	0x64, 0x22, 0x2b, 0xa2, 0x53, 0xa2, 0x5a, 0x33, 0xb1, 0x22, 0xa9, 0x52, 0xa9, 0x9c, 0x30, 0x50,
	0xe8, 0xac, 0x8f, 0x43, 0xd4, 0xc1, 0xb1, 0x13, 0x49, 0x2e, 0xea, 0xef, 0xf6, 0x8f, 0x36, 0x1c,
	0x5e, 0x64, 0x28, 0x2e, 0x8d, 0xe1, 0x45, 0xe9, 0x47, 0x29, 0x74, 0x45, 0x90, 0xe2, 0x98, 0x4c,
	0xc9, 0x6c, 0xe0, 0x55, 0x98, 0x3e, 0x87, 0x01, 0x6e, 0x32, 0x9e, 0xa3, 0x1f, 0xe8, 0x71, 0x7b,
	0x4a, 0x66, 0x1d, 0xef, 0xa0, 0x7e, 0x38, 0xd3, 0xf4, 0x0d, 0x0c, 0x52, 0x2e, 0xfc, 0x2c, 0xe7,
	0x11, 0x8e, 0xbb, 0x53, 0x32, 0x1b, 0xce, 0x9f, 0xb1, 0xda, 0x9a, 0x95, 0xd6, 0xcc, 0x58, 0xb3,
	0x77, 0x92, 0x0b, 0xb7, 0x7b, 0xf5, 0xeb, 0x45, 0xcb, 0x3b, 0x48, 0xb9, 0xb8, 0x2c, 0x05, 0xf4,
	0x14, 0x40, 0xe1, 0x72, 0x69, 0xe4, 0xbd, 0x3d, 0x72, 0x6f, 0x50, 0x92, 0x6b, 0xe5, 0x27, 0x18,
	0x2e, 0x78, 0xb2, 0x40, 0xa5, 0xfd, 0x90, 0xc7, 0xe3, 0x7e, 0x25, 0x9d, 0xb3, 0xfb, 0x16, 0xc5,
	0x1a, 0xe3, 0xba, 0x3c, 0xf6, 0xc0, 0xb4, 0x71, 0x79, 0x6c, 0xff, 0x26, 0x60, 0x9f, 0x45, 0x9a,
	0xaf, 0xb1, 0x41, 0x55, 0xe7, 0xe5, 0xc4, 0x81, 0xe6, 0x52, 0xd0, 0x0d, 0x3c, 0xae, 0xe6, 0x2f,
	0xfc, 0xb0, 0xf0, 0xcd, 0xba, 0x3a, 0xb3, 0xe1, 0xdc, 0xbb, 0xdf, 0x7e, 0x7f, 0x67, 0x56, 0xc1,
	0xc2, 0x2d, 0x3e, 0x06, 0x29, 0x9e, 0x0b, 0x9d, 0x17, 0xde, 0x23, 0xbc, 0xf5, 0x34, 0x79, 0x0b,
	0x87, 0x0d, 0x0a, 0x7d, 0x02, 0x9d, 0x2f, 0x58, 0x98, 0xc8, 0x4a, 0x48, 0x47, 0xd0, 0x5b, 0x07,
	0xcb, 0x15, 0x9a, 0xb4, 0xea, 0xe2, 0x75, 0xfb, 0x94, 0xd8, 0x08, 0xa3, 0xbb, 0xb6, 0x40, 0x9f,
	0x42, 0x3f, 0xe4, 0x71, 0x8c, 0xb9, 0x69, 0x63, 0x2a, 0xfa, 0x12, 0x7a, 0x75, 0x36, 0xed, 0xff,
	0x8b, 0xb6, 0x66, 0xdb, 0xdf, 0x08, 0x1c, 0xbd, 0xe7, 0x4a, 0xcb, 0x9c, 0x47, 0xc1, 0xb2, 0x39,
	0x32, 0x4d, 0x60, 0x74, 0xc7, 0xef, 0xae, 0xcc, 0x22, 0x9d, 0x87, 0xe6, 0x58, 0x9b, 0x53, 0xd9,
	0x30, 0x72, 0x3f, 0x5c, 0x6d, 0x2d, 0x72, 0xbd, 0xb5, 0xc8, 0x9f, 0xad, 0x45, 0xbe, 0xef, 0xac,
	0xd6, 0xf5, 0xce, 0x6a, 0xfd, 0xdc, 0x59, 0xad, 0xcf, 0xf3, 0x84, 0xeb, 0xc5, 0x2a, 0x64, 0x91,
	0x4c, 0x9d, 0x7f, 0xdc, 0xe5, 0xfa, 0xc4, 0xd9, 0x98, 0xe3, 0xd4, 0x45, 0x86, 0x2a, 0xec, 0x57,
	0xb7, 0x73, 0xf2, 0x37, 0x00, 0x00, 0xff, 0xff, 0x18, 0xb2, 0x5c, 0x88, 0xc9, 0x03, 0x00, 0x00,
}

func (m *OpenPurchaseOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenPurchaseOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenPurchaseOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HighestBid != nil {
		{
			size, err := m.HighestBid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenPurchaseOrder(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SellPrice != nil {
		{
			size, err := m.SellPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOpenPurchaseOrder(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.MinPrice.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOpenPurchaseOrder(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ExpireAt != 0 {
		i = encodeVarintOpenPurchaseOrder(dAtA, i, uint64(m.ExpireAt))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOpenPurchaseOrder(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActiveOpenPurchaseOrdersExpiration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveOpenPurchaseOrdersExpiration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActiveOpenPurchaseOrdersExpiration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExpiryByName) > 0 {
		for k := range m.ExpiryByName {
			v := m.ExpiryByName[k]
			baseI := i
			i = encodeVarintOpenPurchaseOrder(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintOpenPurchaseOrder(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintOpenPurchaseOrder(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OpenPurchaseOrderBid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenPurchaseOrderBid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenPurchaseOrderBid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Price.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOpenPurchaseOrder(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Bidder) > 0 {
		i -= len(m.Bidder)
		copy(dAtA[i:], m.Bidder)
		i = encodeVarintOpenPurchaseOrder(dAtA, i, uint64(len(m.Bidder)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HistoricalOpenPurchaseOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistoricalOpenPurchaseOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HistoricalOpenPurchaseOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OpenPurchaseOrders) > 0 {
		for iNdEx := len(m.OpenPurchaseOrders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OpenPurchaseOrders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOpenPurchaseOrder(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintOpenPurchaseOrder(dAtA []byte, offset int, v uint64) int {
	offset -= sovOpenPurchaseOrder(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OpenPurchaseOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenPurchaseOrder(uint64(l))
	}
	if m.ExpireAt != 0 {
		n += 1 + sovOpenPurchaseOrder(uint64(m.ExpireAt))
	}
	l = m.MinPrice.Size()
	n += 1 + l + sovOpenPurchaseOrder(uint64(l))
	if m.SellPrice != nil {
		l = m.SellPrice.Size()
		n += 1 + l + sovOpenPurchaseOrder(uint64(l))
	}
	if m.HighestBid != nil {
		l = m.HighestBid.Size()
		n += 1 + l + sovOpenPurchaseOrder(uint64(l))
	}
	return n
}

func (m *ActiveOpenPurchaseOrdersExpiration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExpiryByName) > 0 {
		for k, v := range m.ExpiryByName {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovOpenPurchaseOrder(uint64(len(k))) + 1 + sovOpenPurchaseOrder(uint64(v))
			n += mapEntrySize + 1 + sovOpenPurchaseOrder(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *OpenPurchaseOrderBid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bidder)
	if l > 0 {
		n += 1 + l + sovOpenPurchaseOrder(uint64(l))
	}
	l = m.Price.Size()
	n += 1 + l + sovOpenPurchaseOrder(uint64(l))
	return n
}

func (m *HistoricalOpenPurchaseOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OpenPurchaseOrders) > 0 {
		for _, e := range m.OpenPurchaseOrders {
			l = e.Size()
			n += 1 + l + sovOpenPurchaseOrder(uint64(l))
		}
	}
	return n
}

func sovOpenPurchaseOrder(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOpenPurchaseOrder(x uint64) (n int) {
	return sovOpenPurchaseOrder(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OpenPurchaseOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenPurchaseOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenPurchaseOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenPurchaseOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenPurchaseOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireAt", wireType)
			}
			m.ExpireAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenPurchaseOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenPurchaseOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenPurchaseOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SellPrice == nil {
				m.SellPrice = &types.Coin{}
			}
			if err := m.SellPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestBid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenPurchaseOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HighestBid == nil {
				m.HighestBid = &OpenPurchaseOrderBid{}
			}
			if err := m.HighestBid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenPurchaseOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveOpenPurchaseOrdersExpiration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenPurchaseOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveOpenPurchaseOrdersExpiration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveOpenPurchaseOrdersExpiration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryByName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenPurchaseOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiryByName == nil {
				m.ExpiryByName = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenPurchaseOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenPurchaseOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOpenPurchaseOrder
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthOpenPurchaseOrder
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenPurchaseOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOpenPurchaseOrder(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOpenPurchaseOrder
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ExpiryByName[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenPurchaseOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenPurchaseOrderBid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenPurchaseOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenPurchaseOrderBid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenPurchaseOrderBid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenPurchaseOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bidder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenPurchaseOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenPurchaseOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistoricalOpenPurchaseOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenPurchaseOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistoricalOpenPurchaseOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistoricalOpenPurchaseOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenPurchaseOrders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenPurchaseOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenPurchaseOrders = append(m.OpenPurchaseOrders, OpenPurchaseOrder{})
			if err := m.OpenPurchaseOrders[len(m.OpenPurchaseOrders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenPurchaseOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOpenPurchaseOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOpenPurchaseOrder(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOpenPurchaseOrder
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpenPurchaseOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpenPurchaseOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOpenPurchaseOrder
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOpenPurchaseOrder
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOpenPurchaseOrder
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOpenPurchaseOrder        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOpenPurchaseOrder          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOpenPurchaseOrder = fmt.Errorf("proto: unexpected end of group")
)
